<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Knapsack problem(Dynamic Programming) ｜ 背包问题汇总</title>
      <link href="/2022/01/26/DpBag/"/>
      <url>/2022/01/26/DpBag/</url>
      
        <content type="html"><![CDATA[<div class="note info simple"><p>There is no English version for this post, sorry for the inconvenience.</p></div>  <h1>背包问题分类</h1><h2 id="常见的背包类型主要有以下几种：">常见的背包类型主要有以下几种：</h2><ol><li>0/1背包问题：每个元素最多选取一次</li><li>完全背包问题：每个元素可以重复选择</li><li>组合背包问题：背包中的物品要考虑顺序</li><li>分组背包问题：不止一个背包，需要遍历每个背包</li></ol><h2 id="问题分类">问题分类</h2><p>而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：</p><ol><li>最值问题：要求最大值/最小值</li><li>存在问题：是否存在………，满足…</li><li>组合问题：求所有满足…的排列组合</li></ol><h2 id="组合分类">组合分类</h2><p>因此把背包类型和问题类型结合起来就会出现以下细分的题目类型：</p><ol><li>0/1背包最值问题</li><li>0/1背包存在问题</li><li>0/1背包组合问题</li><li>完全背包最值问题</li><li>完全背包存在问题</li><li>完全背包组合问题</li><li>分组背包最值问题</li><li>分组背包存在问题</li><li>分组背包组合问题</li></ol><hr><h1>模版</h1><h2 id="背包分类的模版">背包分类的模版</h2><ol><li>0/1背包：<code>外循环nums,内循环target,target倒序且target&gt;=nums[];</code></li><li>完全背包：<code>外循环nums,内循环target,targeti正序且target&gt;=nums[i];</code></li><li>组合背包：<code>外循环target,内循环nums,target.正序且target&gt;=nums[i];</code></li><li>分组背包：这个比较特殊，需要三重循环：外循环背包ba9s,内部两层循环根据题目的要求转化为1,2,3三<br>种背包类型的模板</li></ol><h2 id="问题分类的模板：">问题分类的模板：</h2><ol><li>最值问题：<code>dp[]=max/min(dp[i],dp[i-nums]+1)或dp[]=max/min(dp[],dp[i-num]+nums);</code></li><li>存在问题(bool):<code>dp[i]=dp[i]lldp[i-num];</code></li><li>组合问题：<code>dp[]+=dp[i-num];</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting Algorithm | 排序算法(Python)</title>
      <link href="/2022/01/04/sortAlgo/"/>
      <url>/2022/01/04/sortAlgo/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center"><strong>排序算法</strong></th><th style="text-align:center">Average T(n)</th><th style="text-align:center">Best case</th><th style="text-align:center">Worst Case</th><th style="text-align:center">Space-Complexity</th></tr></thead><tbody><tr><td style="text-align:center">Bubble Sort</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O($^2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Selection Sort</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Insertion Sort</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Shell Sort</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlog^2n)</td><td style="text-align:center">O(nlog^2n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Merge Sort</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">Quick Sort</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(logn)</td></tr><tr><td style="text-align:center">Heap Sort</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">Counting Sort</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">O(k)</td></tr><tr><td style="text-align:center">Selection Sort</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n+k)</td></tr><tr><td style="text-align:center">Selection Sort</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n*k)</td><td style="text-align:center">O(n+k)</td></tr></tbody></table><h1>Insertion Sort | 插入排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">    cur = nums[i]</span><br><span class="line">    j = i -<span class="number">1</span></span><br><span class="line">    <span class="comment">#如果发现cur元素比上一个元素(j)小，那么就将cur前移，直到cur大于前一个元素，而j在之中的作用就是移动之前元素的作用</span></span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; cur:</span><br><span class="line">      nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">    <span class="comment">#跳出循环后的j元素是比cur小的，那么j+1就是cur元素的位置</span></span><br><span class="line">    nums[j + <span class="number">1</span>] = cur </span><br></pre></td></tr></table></figure><h1>Bubble Sort | 冒泡排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   n = <span class="built_in">len</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># Last i elements are already in place</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] :</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]    </span><br></pre></td></tr></table></figure><h1>Quick Sort| 快排</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Pivot选取的是arr[high]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr,low,high</span>):</span> </span><br><span class="line">    <span class="comment"># 最小元素索引</span></span><br><span class="line">    i = ( low-<span class="number">1</span> )         </span><br><span class="line">    pivot = arr[high]     </span><br><span class="line">  </span><br><span class="line">    <span class="comment">#遍历所有</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low , high):  </span><br><span class="line">        <span class="comment"># 当前元素小于或等于 pivot ，</span></span><br><span class="line">        <span class="keyword">if</span>   arr[j] &lt;= pivot:     </span><br><span class="line">            <span class="comment">#i是用来给小于pivot的数创造空间的</span></span><br><span class="line">            i = i+<span class="number">1</span> </span><br><span class="line">            arr[i],arr[j] = arr[j],arr[i] </span><br><span class="line">    <span class="comment">#将pivot放在中间位置</span></span><br><span class="line">    arr[i+<span class="number">1</span>],arr[high] = arr[high],arr[i+<span class="number">1</span>]  </span><br><span class="line">    <span class="comment">#将pivot的值返回</span></span><br><span class="line">    <span class="keyword">return</span> ( i+<span class="number">1</span> )</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 快速排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">arr,low,high</span>):</span> </span><br><span class="line">    <span class="comment">#跳出条件 low指针与high指针相遇，意味着区间为1</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:  </span><br><span class="line">        <span class="comment">#partition有两个作用：1.返回pi 2.顺便排序</span></span><br><span class="line">        pi = partition(arr,low,high) </span><br><span class="line">        quickSort(arr, low, pi-<span class="number">1</span>) </span><br><span class="line">        quickSort(arr, pi+<span class="number">1</span>, high) </span><br></pre></td></tr></table></figure><h1>Selection Sort | 选择排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)): </span><br><span class="line">    <span class="comment">#这个操作就很优雅，如果选择每次遍历的元素，相当于每次的i都是遍历队列的开头。</span></span><br><span class="line">    min_idx = i </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(A)): </span><br><span class="line">        <span class="keyword">if</span> A[min_idx] &gt; A[j]: </span><br><span class="line">            min_idx = j </span><br><span class="line">    A[i], A[min_idx] = A[min_idx], A[i] </span><br></pre></td></tr></table></figure><h1>Merge Sort ｜ 归并排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">arr, l, m, r</span>):</span> </span><br><span class="line">    n1 = m - l + <span class="number">1</span> <span class="comment">#左列 包含 m，所以+1</span></span><br><span class="line">    n2 = r- m <span class="comment">#右列</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 创建临时数组</span></span><br><span class="line">    L = [<span class="number">0</span>] * (n1)</span><br><span class="line">    R = [<span class="number">0</span>] * (n2)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝数据到临时数组 arrays L[] 和 R[] </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , n1): </span><br><span class="line">        L[i] = arr[l + i] </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , n2): </span><br><span class="line">        R[j] = arr[m + <span class="number">1</span> + j] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 归并临时数组到 arr[l..r] </span></span><br><span class="line">    i = <span class="number">0</span>     <span class="comment"># 初始化第一个子数组的索引</span></span><br><span class="line">    j = <span class="number">0</span>     <span class="comment"># 初始化第二个子数组的索引</span></span><br><span class="line">    <span class="comment">#这个很重要，因为归并是从最细颗粒度开始操作的，因此开始操作时对象已经完全转为原数组了。</span></span><br><span class="line">    k = l     <span class="comment"># 初始归并子数组的索引 </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">#下面3段while就是将分组按顺序排列起来。 </span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2 : </span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]: </span><br><span class="line">            arr[k] = L[i] </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            arr[k] = R[j] </span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 拷贝 L[] 的保留元素</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1: </span><br><span class="line">        arr[k] = L[i] </span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 拷贝 R[] 的保留元素</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; n2: </span><br><span class="line">        arr[k] = R[j] </span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#分别为0和 len(nums) - 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>):</span>  </span><br><span class="line">    <span class="comment">#判断条件就不进行了，相当于None</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r: </span><br><span class="line">        <span class="comment">#求中点：处理上-1是因为如果总数为4，那么想取第二个数而非第三个。    </span></span><br><span class="line">        m = <span class="built_in">int</span>((l+(r-<span class="number">1</span>))/<span class="number">2</span>)</span><br><span class="line">        mergeSort(arr, l, m) </span><br><span class="line">        mergeSort(arr, m+<span class="number">1</span>, r) </span><br><span class="line">        merge(arr, l, m, r) </span><br><span class="line">  </span><br></pre></td></tr></table></figure><h1>Heap Sort | 堆排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#n代表有多少个节点，i代表目前针对那个节点做文章  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">arr, n, i</span>):</span> </span><br><span class="line">    <span class="comment"># left = 2*i + 1 i节点下的左节点的index</span></span><br><span class="line">    <span class="comment"># right =2*i + 2 i节点下的右节点的index</span></span><br><span class="line">    <span class="comment">#i节点的根节点为 root=(i-1)/2</span></span><br><span class="line">    largest = i  </span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span>     </span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span>     </span><br><span class="line"></span><br><span class="line">    <span class="comment">#下面3个if是用来交换二叉树中的值的，构造完全二叉树</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[i] &lt; arr[l]: </span><br><span class="line">        largest = l </span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]: </span><br><span class="line">        largest = r </span><br><span class="line">    <span class="comment">#上述两个if是用来比较，下面这个是把根节点交换成最大值</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:  </span><br><span class="line">        arr[i],arr[largest] = arr[largest],arr[i]  <span class="comment"># 交换</span></span><br><span class="line">        <span class="comment">#对下面节点继续heapify</span></span><br><span class="line">        heapify(arr, n, largest) </span><br><span class="line">    <span class="comment"># 上面这个对子树进行heapify比较难理解：首先我们是从最子节点开始构建堆的，所以已经确保了子树的堆结构</span></span><br><span class="line">    <span class="comment"># 如果我们进行了交换，就没有办法保证已经确保的子树还满足完全二叉树的结构，也就是大小关系，因此要对交换过的子树进行这种处理。</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">arr</span>):</span> </span><br><span class="line">    n = <span class="built_in">len</span>(arr) </span><br><span class="line">    <span class="comment"># Build a maxheap. </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, -<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">        <span class="comment">#倒序建堆，意味着从最底层子树开始建堆</span></span><br><span class="line">        heapify(arr, n, i)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 一个个交换元素</span></span><br><span class="line">    <span class="comment"># 为什么要这么处理就是，上面已经建好堆了， 也就是最大值就在root处。 root跟尾节点交换，然后切断尾部。交换过后破坏了堆的形式，那么这个时候只用针对根节点进行heapify就好了。</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):  <span class="comment">#i 倒序 —— 这里就是切尾巴的操作</span></span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  </span><br><span class="line">        <span class="comment"># size为i，每次针对0根节点进行heapify</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>) </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1>Shell Sort | 希尔排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">arr</span>):</span> </span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 这里不是一分为二，而是表示间隔</span></span><br><span class="line">    gap = <span class="built_in">int</span>(n/<span class="number">2</span>) </span><br><span class="line">    <span class="comment">#充当迭代的作用</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>: </span><br><span class="line">        <span class="comment">#遍历后序列 </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,n):  </span><br><span class="line">            temp = a rr[i] </span><br><span class="line">            j = i </span><br><span class="line">            <span class="keyword">while</span>  j &gt;= gap <span class="keyword">and</span> arr[j-gap] &gt;temp: </span><br><span class="line">                arr[j] = arr[j-gap] </span><br><span class="line">                j -= gap </span><br><span class="line">            arr[j] = temp </span><br><span class="line">        <span class="comment"># 将间隔变小</span></span><br><span class="line">        gap = <span class="built_in">int</span>(gap/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1>Count Sort ｜ 基数排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSort</span>(<span class="params">arr</span>):</span> </span><br><span class="line">    output = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)] </span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)] </span><br><span class="line">    ans = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> arr] </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr: </span><br><span class="line">        count[<span class="built_in">ord</span>(i)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>): </span><br><span class="line">        count[i] += count[i-<span class="number">1</span>] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)): </span><br><span class="line">        output[count[<span class="built_in">ord</span>(arr[i])]-<span class="number">1</span>] = arr[i] </span><br><span class="line">        count[<span class="built_in">ord</span>(arr[i])] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)): </span><br><span class="line">        ans[i] = output[i] </span><br><span class="line">    <span class="keyword">return</span> ans  </span><br></pre></td></tr></table></figure><h1>Counting Sort ｜ 计数排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span>(<span class="params">arr, maxValue</span>):</span></span><br><span class="line">    bucketLen = maxValue+<span class="number">1</span> <span class="comment">#最大值</span></span><br><span class="line">    bucket = [<span class="number">0</span>]*bucketLen <span class="comment">#数组</span></span><br><span class="line">    sortedIndex =<span class="number">0</span> <span class="comment">#排序的index</span></span><br><span class="line">    arrLen = <span class="built_in">len</span>(arr) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(arrLen):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bucket[arr[i]]:</span><br><span class="line">            bucket[arr[i]]=<span class="number">0</span></span><br><span class="line">        bucket[arr[i]]+=<span class="number">1</span> </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(bucketLen):</span><br><span class="line">        <span class="keyword">while</span> bucket[j]&gt;<span class="number">0</span>:</span><br><span class="line">            arr[sortedIndex] = j</span><br><span class="line">            sortedIndex+=<span class="number">1</span></span><br><span class="line">            bucket[j]-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h1>Bucket Sort ｜ 桶排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort_simplify</span>(<span class="params">arr, max_num</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果最大值为100，那么创建1～100的桶</span></span><br><span class="line">    bucket = &#123;i: [] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(max_num)+<span class="number">1</span>)&#125;  </span><br><span class="line">    arr_len = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(arr_len): <span class="comment">#遍历数组，然后加入桶中</span></span><br><span class="line">        num = arr[i]</span><br><span class="line">        bucket[<span class="built_in">int</span>(num)].append(num)  <span class="comment"># 将相应范围内的数据加入到[]中</span></span><br><span class="line">    arr = [] <span class="comment">#这个其实就是result</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bucket)):</span><br><span class="line">        <span class="keyword">if</span> bucket[i]:<span class="comment">#桶里有值的话，可以加入</span></span><br><span class="line">            arr.extend(<span class="built_in">sorted</span>(buf[i]))  <span class="comment"># 这里还需要对一个范围内的数据进行排序，然后再进行输出</span></span><br><span class="line">            <span class="comment">#.extend()可以在队尾一次性添加多个值</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Why we need Webpack? | Webpack是用来干什么的？打包？</title>
      <link href="/2021/12/01/introToWebpack/"/>
      <url>/2021/12/01/introToWebpack/</url>
      
        <content type="html"><![CDATA[<div class="note Modern flat"><p><strong><font size = 5>What Webpack does is bundling.</font></strong><br><strong><font size = 5>So first, we need to get to know the concept of bundle.</font></strong></p></div>  <h1>What do we need to know about bundling</h1><ol><li>The decision to package or not is based on the complexity of the project.</li><li>The front-end codes are written in many files, which increases Http requests and slowers page loading. With bundling, many fragmented files are concentrated into a whole file improving page rendering efficiency.</li><li>During bundling, the ES6, Sass and other advanced syntax will be converted to be compatible with higher versions of browsers</li></ol><p>In order to understand the practical value of packaging, we need to take a little look at the history of <strong>front-end development</strong>.</p><h1>A quick look at the history of front end</h1><p>JavaScript, in the absence of Node, can only be run by <code>&lt;script&gt;</code> tags inserted into HTML. If a website has a lot of functions and I want to write 15 js files by function, then I have to insert 15 <code>&lt;script src=&quot;&quot;&gt;</code> to refer to those JS files, paying attention to the order of references and the position of insertion, which is difficult to maintain on the one hand, and increases the number of requests when the page loads on the other.</p><p>Since the introduction of Node, individual JS file can be run in the terminal after leaving the HTML, and we front-end can play programming in the command line like any other language! With the implementation of the modularity standard, JS has the concept of “import” and “export”, which has revolutionized the way we code without the pain of having to write 15 <code>&lt;script src=&quot;&quot;&gt;</code>s in HTML. I just insert a general script tag as the entry point, and the other 14 js files are exported as modules and imported into the entry point JS (usually called main.js, the 15 jS files can also be imported and exported to each other or something, after all, in a Node environment, each JS file is a separate module).</p><p>But the problem is that once the JS file is inserted into html as <code>&lt;script src=&quot;&quot;&gt;</code>, then module syntax like <strong>require, export, import, etc</strong>. will report an error because browsers don’t support modularity and module syntax is built to be available in the Node environment. one of the things that bundling tools like Webpack do is allowing us to insert a script tag, but also allows us to use export, import, require syntax between JS files, and very intelligently merge and compress these JS modules into one (or two or more) big tight JS files.</p><p><strong>To sum up: the Bundling tool allows us to use import export require when developing web pages and modularize them like a back-end programmer.</strong></p><hr><h1>关于打包，我们要了解什么。</h1><ol><li>要根据项目复杂程度决定是否打包。</li><li>前端写代码时为了方便会将代码写在许多文件中，会使页面进行的http衍生请求次数的次数增多，页面加载耗能增加。使用打包过后将许多零碎的文件打包成一个整体，页面只需请求一次，提高页面渲染效率。</li><li>打包同时会进行编译，将ES6、Sass等高级语法进行转换编译，以兼容高版本的浏览器<br>仅此而已，还是难以充分证明为什么我们需要打包以及它的实用价值，这里我们需要稍微看一下前端的发展历史。<br>为了了解打包的实用价值，我们需要稍微看一下<strong>前端的发展历史</strong></li></ol><h1>浅尝前端发展</h1><p>JS作为一门脚本语言，在没有Node的时候，只能通过<code>&lt;script&gt;</code>标签插进html去运行，单个的js文件离开了html他什么都不是。如果一个网站功能很多，我要按照功能划分写15个js文件，那我就要插入15个<code>&lt;script src=&quot;&quot;&gt;</code>去引那些js文件，还需要注意引用顺序和插入的位置，一方面难以维护，一方面增加了网页加载时的请求数量。</p><p>自从有了Node之后，单个的js文件离开了html以后也可以在终端run起来了，我们前端可以和别的语言一样在命令行里玩编程！模块化标准实施之后，js就有了“引入”和“导出”的概念，这带来的革命性变化便是：当我们写业务的时候再也不用蛋疼地去在html里写15个<code>&lt;script src=&quot;&quot;&gt;</code>去运行js了。我只要插入一个作为入口的总的script标签，另外的14个js文件都作为模块导出，并导入到这个入口的js（通常叫main.js，这15个js文件也可以互相导入导出什么的，毕竟在Node环境下，每个js文件都是一个单独的模块）。</p><p>但问题在于，一旦js文件以<code>&lt;script src=&quot;&quot;&gt;</code>的形式插入html，那么require、export、import之类的模块语法就会报错，因为浏览器不支持模块化，模块语法是建立在Node的环境下才有的。webpack等打包工具的一个作用就是让我们插入一个script标签的同时，还允许我们在js文件之间使用export、import、require这些语法，并且非常智能地把这些js模块合并压缩成1个（或2个或以上）大大的紧实的js文件。</p><p><strong>总结：打包工具可以让我们在开发网页的时候使用import/exportrequire，像后端程序员那样进行模块化开发。</strong></p><h1>Useful Link</h1><p><a href='https://webpack.docschina.org/concepts/why-webpack/'> Click Me -&gt; Why-webpack</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basics </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack VS Heap</title>
      <link href="/2021/10/16/stackVsHeap/"/>
      <url>/2021/10/16/stackVsHeap/</url>
      
        <content type="html"><![CDATA[<h2 id="font-size-5-Q-Why-there-are-stack-and-heap-What-is-the-difference-font-font-size-5-A-Before-talking-about-the-diff-we-first-think-about-WHY-font"><strong><font size = 5>Q:  Why there are stack and heap?  What is the difference?</font></strong><br><strong><font size = 5>A:  Before talking about the diff, we first think about WHY. </font></strong></h2><h1>WHY</h1><h2 id="Software-design-perspective">Software design perspective</h2><p>The stack represents the processing logic, while the heap represents the data. This separation makes the processing logic clearer. The idea of divide-and-conquer. This idea of isolation and modularity is reflected in all aspects of software design.</p><h2 id="The-heap-can-be-shared-by-stacks">The heap can be shared by stacks</h2><p>The separation of the heap from the stack allows the contents of the heap to be shared by multiple stacks(which can also be interpreted as multiple threads accessing the same object). The benefits of this sharing are many. On the one hand this sharing provides an efficient way to interact with data (e.g., shared memory), and on the other hand, the shared constants and caches in the heap can be accessed by all stacks, saving space.</p><h2 id="Stack’s-needs">Stack’s needs</h2><p>Stack’s ruuning requires address segments such as keeping the context. Since the stack can only grow upward, it limits the stack’s ability to store content. Unlike the heap, the objects in the heap can grow dynamically as needed, so the split between the stack and the heap makes dynamic growth possible, and the corresponding stack only needs to record an address in the heap.</p><h2 id="Object-Oriented-is-the-peferct-outcome-of-combination-of-heap-and-stack">Object-Oriented is the peferct outcome of combination of heap and stack</h2><p>In fact, OOP has no difference in running with previous structured programming. However, the introduction of object-oriented makes the way of thinking about problems change, and closer to the natural way of thinking. When we take the object apart, you find that the properties of the object are actually the data, stored in the heap; and the behavior of the object (methods), which is the runtime logic, is placed on the stack. When we write the object, we actually write the data structure, but also write the logic to handle the data.</p><div class="note info simple"><p>In Java, the Main function is the starting point of the stack, and the starting point of the program There is always a starting point for a program to run. No matter what java program, Main is the entrance to the execution of the program :)</p></div><h1>What is stored in Stack and Heap?</h1><p>The heap holds objects. The stack holds basic data types and references to  objects in the heap. The size of an object is not estimable, or can change dynamically, but in the stack, an object corresponds to only one 4btye reference.</p><h2 id="Why-not-put-the-basic-type-in-the-heap">Why not put the basic type in the heap?</h2><p>Because the space it occupies is generally 1 to 8 bytes - need less space, and because it is a basic type, so there will be no dynamic growth - the length is fixed, so the stack storage is enough, if he exists in the heap is not much sense There is no point in storing it in the heap (and wasting space, as explained later). So to speak, basic types and object references are stored on the stack, and both are a few bytes of a number, so at program runtime, they are handled in a uniform way. But basic types, object references and objects themselves are different, because one is the data on the stack and one is the data in the heap.</p><h1>Comment</h1><p>Personally think the seperation of stack and heap actually stands the beauty of design thoughts.</p><hr><h1>堆栈为什么要分离？ （转载自Useful Link）</h1><ol><li>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li><li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li><li>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li><li>面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</li></ol><h1>堆和栈里面储存了什么？</h1><p>堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用。</p><h2 id="为什么不把基本类型放堆中呢？">为什么不把基本类型放堆中呢？</h2><p>因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。</p><h1>Userful Link</h1><p><a href="https://www.cnblogs.com/andy-zhou/p/5327288.html">Click Me -&gt; JVM调优</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习扫盲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basics </tag>
            
            <tag> Operation System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP &amp; HTTPS</title>
      <link href="/2021/09/16/http-https/"/>
      <url>/2021/09/16/http-https/</url>
      
        <content type="html"><![CDATA[<h1>HTTP &amp; HTTPS</h1><p>The data transmitted by HTTP are unencrypted, that is, plaintext. Netscape has set up SSL protocol to encrypt the data transmitted by HTTP protocol. Simply put, HTTPS protocol is a network protocol built from HTTP and SSL protocol that can be used for encrypted transmission and authentication, which is more secure than HTTP protocol. The main differences are as follows.</p><ol><li>HTTPS protocol requires ca certificate</li><li>HTTP is a hypertext transfer protocol where information is transmitted in clear text; HTTPS is an SSL encrypted transfer protocol with security</li><li>HTTP protocol port is 80, HTTPS port is 443</li><li>The HTTP connection is simple and stateless; HTTPS protocol is a network protocol constructed by SSL + HTTP protocol that allows encrypted transmission and authentication, which is more secure than the HTTP protocol</li></ol><h1>Status code</h1><ul><li>1xx Request received by server</li><li>2xx Request successful e.g. 200</li><li>3xx Redirected</li><li>4xx Client error e.g. 404</li><li>5xx Server-side error e.g. 505</li></ul><h2 id="Common-Status-Codes">Common Status Codes</h2><ul><li>200 Success</li><li>301 Permanent redirection (with location, automatically handled by browser)</li><li>302 Temporary redirect (with location, automatically handled by browser)</li><li>304 Resource has not been modified</li><li>404 Resource not found</li><li>403 No permission</li><li>500 Server error</li><li>504 Gateway timeout</li></ul><hr><h1>HTTP &amp; HTTPS区别</h1><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。主要的区别如下：</p><ol><li>Https协议需要ca证书</li><li>http是超文本传输协议，信息是明文传输；https则是具有安全性的ssl加密传输协议</li><li>http协议的端口为80，https的端口为443</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</li></ol><h1>状态码</h1><ul><li>1xx 服务器收到请求</li><li>2xx 请求成功 如200</li><li>3xx 重定向</li><li>4xx 客户端错误 如404</li><li>5xx 服务端错误 如505</li></ul><h2 id="常用状态码">常用状态码</h2><ul><li>200 成功</li><li>301 永久重定向（配合location，浏览器自动处理）</li><li>302 临时重定向（配合location，浏览器自动处理）</li><li>304 资源未被修改</li><li>404 资源未找到</li><li>403 没有权限</li><li>500 服务器错误</li><li>504 网关超时</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习扫盲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Why asynchronous and its application scenarios｜为什么需要异步与其场景</title>
      <link href="/2021/09/04/introToAsync/"/>
      <url>/2021/09/04/introToAsync/</url>
      
        <content type="html"><![CDATA[<h2 id="Premise">Premise |</h2><p>Javascript is a single-threaded language. This means it has a call stack and a memory heap. As expected, it executes code sequentially, and a piece of code must complete before executing the next piece of code. It’s synchronous, but can be detrimental at times.</p><h2 id="When-do-you-need-async">When do you need async |</h2><ol><li>When waiting may occur</li><li>When the program cannot be blocked like an alarm during the wait</li><li>All “wait cases” need to be asynchronous<br><br /></li></ol><p>In a word, you need to use asynchronous when you need to wait but not block the program.</p><h2 id="Asynchronous-scenarios">Asynchronous scenarios |</h2><p>The following scenarios all need to wait, but the program cannot be blocked during the waiting process, so it needs to be asynchronous. The asynchronous design is mainly because javascript is a single-threaded language, and a single thread only allows to do one thing at the time. If You need to do more than one thing at the same time, then the others need to go to the side queue. Possible async scenarios:</p><ol><li>Timeing tasks: setTimeout, setInterval</li><li>Network request: Ajax, Dynamically loading images</li><li>Event binding or DOM events. When the event triggered, the corresponding function will be thrown into the asynchronous queue. If the execution stack is empty, execute the function directly.</li><li>Promise function in ES6</li></ol><h2 id="Comment">Comment |</h2><p>I know it may kind of hard to understand such concepts at first. Don’t worry, I was in the same situation as you. When thinking about the concept, try to also consider language feature, hardware limitations and programming efficiency.</p><hr><h2 id="前提">前提</h2><p>Javascript是单线程的语言。这意味着它有一个调用栈和一个内存堆，它是按顺序执行代码的，一段代码必须在执行下一段代码之前完成。</p><h2 id="什么时候需要异步？">什么时候需要异步？</h2><ol><li>可能发生等待时</li><li>当程序在等待期间不能像被Alert阻塞时</li><li>所有可能出现等待的情况，尤其涉及到IO<br>总的来说，当你要等待但不想阻塞程序时，需要使用异步。下面的例子会帮助你的更好的理解^_^</li></ol><h2 id="异步情况">异步情况</h2><p>以下场景都需要等待，但在等待过程中程序不能被阻塞，所以需要异步。异步设计主要是因为javascript是一种单线程语言，而单线程只允许同时只能做一件事情。如果你需要同时做多件事情，那么其他的事情就需要到旁边的队列中去等待。以下为可能需要异步的场景：</p><ol><li>计时任务：setTimeout、setInterval</li><li>网络请求：Ajax，动态加载图片</li><li>事件绑定或DOM事件。当事件被触发时，相应的函数将被抛入异步队列。如果执行栈是空的，则直接执行该函数。</li><li>ES6中的Promise函数</li></ol><h2 id="评论">评论|</h2><p>一开始可能有点难以理解这样的概念，尤其是刚接触这种概念的朋友。别担心，我也是这样的。所以在思考这个概念的时候，尽量同时考虑语言特性、硬件限制和编程效率。这样能够从大方面上更容易理解这种概念，及其明白这种概念出现的原因与必要性。</p>]]></content>
      
      
      <categories>
          
          <category> 前端入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basics </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let, Var &amp; Const</title>
      <link href="/2021/07/04/letVarConst/"/>
      <url>/2021/07/04/letVarConst/</url>
      
        <content type="html"><![CDATA[<font size=3.5><div class="note Modern flat"><p>Let us consider <strong>differences</strong> from following 7 dimensions:</p></div>    <ol><li><p><strong>Block scope:</strong><br>Block scope consists of { }, let and const have block scope, var does not have block scope. Block scope solves two problems in ES5:</p><ul><li>Inner-level variables may overwrite outer-level variables</li><li>Loop variables used for counting leak as global variables</li></ul></li><li><p><strong>Variable lifting:</strong><br>Var has variable lifting, let and const do not have variable lifting, that is, in the variable can only be used after the declaration, otherwise it will report an error.</p></li><li><p><strong>Adding properties to the global:</strong><br>The global object of the browser is window, and the global object of Node is global. var declares a variable as a global variable and adds it as a property of the global object, but let and const do not.</p></li><li><p><strong>Repeated declaration:</strong><br>When var declares a variable, the variable can be repeatedly declared, and the later declared variable with the same name will overwrite the previously declared traversal. const and let do not allow repeated declaration of variables.</p></li><li><p><strong>Temporary dead zone:</strong><br>A variable is not available until it is declared using the let and const commands. This is called temporary dead space in syntax. There is no temporary dead space for variables declared with var.</p></li><li><p><strong>Initial value setting:</strong><br>When variables are declared, var and let can be used without setting the initial value. Const declared variables must have an initial value.</p></li><li><p><strong>Pointer pointing:</strong><br>let and const are both new syntaxes for creating variables in ES6. The variables created by let can change the pointer pointing (can be reassigned). However, variables declared by const are not allowed to change the pointer pointing.</p></li></ol><hr><ol><li><strong>块级作用域：</strong><br>块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：<ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul></li><li><strong>变量提升：</strong><br>var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</li><li><strong>给全局添加属性：</strong><br>浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</li><li><strong>重复声明：</strong><br>var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</li><li><strong>暂时性死区：</strong><br>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。</li><li><strong>初始值设置：</strong><br>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</li><li><strong>指针指向：</strong><br>let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</li></ol></font>]]></content>
      
      
      <categories>
          
          <category> 前端入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basics </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
